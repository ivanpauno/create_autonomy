#! /usr/bin/env python

import rospy
import cv_bridge
import message_filters
import sensor_msgs

import numpy as np

class PointCloudGenerator:
    '''
    Generate a ros point cloud given a color image and a depth image
    \author Xuan Zhang
    \date May - July 2018
    '''
    def __init__(self, intrinsic_matrix, width, height, frame_id):
        '''
        width: (int) width of input images
        height: (int) height of input images
        '''
        self.width = width
        self.height = height
        self.intrinsic_matrix = intrinsic_matrix
        self.frame_id = frame_id
        self.setup = False

    def setup(self):
        x_index = np.array([range(self.width)*self.height], dtype = '<f4')
        y_index = np.array([[i]*self.width for i in range(self.height)], dtype = '<f4').ravel()
        self.xy_index = np.vstack((x_index, y_index)).T # x,y
        self.xyd = np.zeros([self.width * self.height, 3], dtype = '<f4') # x,y,depth
        self.xyz = np.zeros([self.width * self.height, 3], dtype = '<f4') # real world coord
        self.color = np.zeros([self.width * self.height, 4], dtype = '<u1') #bgr0
        self.mask = np.zeros([self.width * self.height, 4], dtype = '<u1') #bgr0

    def __eq__(self, other):
        return self.height == other.height and self.width == other.width \
            and self.frame_id == other.frame_id and \
            self.intrinsic_matrix == other.intrinsic_matrix

    def __ne__(self, other):
        return not (self == other)

    def _make_pointcloud_msg(self, stamp, data):
        msg = sensor_msgs.PointCloud2()
        msg.header.stamp = stamp
        msg.header.frame_id = self.frame_id
        msg.height = 1
        msg.width = self.width * self.height
        msg.fields.append(sensor_msgs.PointField(
            name = "x", offset = 0,
            datatype = sensor_msgs.PointField.FLOAT32,
            count = 1)
        )
        msg.fields.append(sensor_msgs.PointField(
            name = "y", offset = 4,
            datatype = sensor_msgs.PointField.FLOAT32,
            count = 1)
        )
        msg.fields.append(sensor_msgs.PointField(
            name = "z", offset = 8,
            datatype = sensor_msgs.PointField.FLOAT32,
            count = 1)
        )
        msg.fields.append(sensor_msgs.PointField(
            name = "bgr", offset = 16,
            datatype = sensor_msgs.PointField.FLOAT32,
            count = 1
        ))
        msg.fields.append(sensor_msgs.PointField(
            name = "mask", offset = 24,
            datatype = sensor_msgs.PointField.FLOAT32,
            count = 1
        ))
        msg.data = data
        msg.is_bigendian = False
        msg.point_step = 5 * 4  # In bytes
        msg.row_step = msg.point_step * msg.width * msg.height
        msg.is_dense = False
        return msg

    def generate(self, mask_img, depth_img, color_img, stamp):
        if not self.setup:
            self.setup()
        self.xyd[:, 0:2] = self.xy_index * depth_img.reshape(-1, 1)
        self.xyd[:, 2] = depth_img.reshape(-1, 1)
        self.xyz = self.xyd.dot(self.intrinsic_matrix.I.T)
        self.data[:, 0:2] = self.xyz

        self.color[:,0] = color_img[:,:,0].reshape(-1,1)
        self.color[:,1] = color_img[:,:,1].reshape(-1,1)
        self.color[:,2] = color_img[:,:,2].reshape(-1,1)
        self.data[:, 3] = self.color.view('<f4')

        self.mask[:,0] = mask_img[:,:,0].reshape(-1,1)
        self.mask[:,1] = mask_img[:,:,1].reshape(-1,1)
        self.mask[:,2] = mask_img[:,:,2].reshape(-1,1)
        self.data[:, 4] = self.mask.view('<f4')
        return self._make_pointcloud_msg(
            stamp, data=np.getbuffer(self.data.ravel())[:]
        )


class Implementation:

    def __init__(self):
        self._bridge = cv_bridge.CvBridge()
        self._cloud_pub = rospy.Publisher(
           'semantic/cloud', sensor_msgs.PointCloud2, queue_size=1)
        self._mask_sub = message_filters.Subscriber(
           'semantic/color_mask', sensor_msgs.Image,
           queue_size=1, buff_size=30*480*640)
        self._depth_sub = message_filters.Subscriber(
           'depth_registered/image_rect', sensor_msgs.Image,
           queue_size=1, buff_size=30*480*640)
        self._color_sub = message_filters.Subscriber(
           'rgb/image_rect', sensor_msgs.Image,
           queue_size=1, buff_size=30*480*640)
        self._depth_info_sub = rospy.Subscriber(
           'depth_registered/camera_info', sensor_msgs.CameraInfo,
           self._camera_info_callback, queue_size=1)
        self._time_sync = message_filters.ApproximateTimeSynchronizer(
           [self._mask_sub, self._depth_sub, self._color_sub], queue_size=1, slop=0.3)
        # Take in one color image and one depth image with a limite time gap between message time stamps
        self._time_sync.registerCallback(self._mask_depth_callback)

    def _camera_info_callback(self, info):
       cloud_generator = PointCloudGenerator(
          intrinsic=np.array(info.K).reshape(3, 3),
          height=info.height, width=info.width,
          frame_id=info.header.frame_id
       )
       if cloud_generator != self._cloud_generator:
          self._cloud_generator = cloud_generator

    def _mask_depth_callback(self, mask_imgmsg, depth_imgmsg, color_imgmsg):
        if self._cloud_generator is None:
           return
        try:
           mask_img = self._bridge.imgmsg_to_cv2(mask_imgmsg, "bgr8")
           depth_img = self._bridge.imgmsg_to_cv2(depth_imgimg, "32FC1")
           color_img = self._bridge.imgmsg_to_cv2(color_imgmsg, "bgr8")
        except cv_bridge.CvBridgeError as e:
           rospy.logerr(str(e))
        cloud_msg = self._cloud_generator.generate(
           mask_img, depth_img, color_img, mask_imgmsg.header.stamp)
        self._cloud_pub.publish(cloud_msg)


def main():
    rospy.init_node('semantic_cloud', anonymous=True)
    impl = Implementation()
    try:
       rospy.spin()
    except KeyboardInterrupt:
       print("Shutting down")


if __name__ == '__main__':
    main()
